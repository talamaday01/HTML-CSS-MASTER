import _ from 'lodash';

import { githubRequest } from './githubRequest';

export default ({ apiUrl, token, repository, commit, pullRequestId }) => {
  const { log } = console;
  const repositoryUrl = `${apiUrl}/repos/${repository}`;
  const issuesUrl = `${repositoryUrl}/issues`;
  const allCommentsUrl = `${issuesUrl}/comments`;
  const issueUrl = `${issuesUrl}/${pullRequestId}`;
  const labelUrl = `${issueUrl}/labels`;
  const commentUrl = `${issueUrl}/comments`;

  // Get the labels of the current PR
  const getLabels = () => {
    if (commit && repository && pullRequestId) {
      return githubRequest(token, labelUrl).then(data => _.map(data, 'name'));
    }

    return Promise.resolve([]);
  };

  const pushLabel = label => {
    if (repository && label) {
      return getLabels().then(currentLabels => {
        if (!_.includes(currentLabels, label)) {
          githubRequest(token, labelUrl, 'POST', [label]);
        }
      });
    }

    return Promise.resolve();
  };

  // Set a Github status
  const STATUSES = {
    PENDING: 'pending',
    SUCCESS: 'success',
    ERROR: 'error',
    FAILURE: 'failure',
  };

  const setStatus = (state, targetUrl = '', context = 'default', description = 'default') => {
    if (commit && repository) {
      log(`Set Github status to "${state}" for "${context}".`);

      const statusUrl = `${repositoryUrl}/statuses/${commit}`;

      return githubRequest(token, statusUrl, 'POST', {
        state,
        target_url: targetUrl,
        description,
        context,
      });
    }

    return Promise.resolve();
  };

  const pushComment = messageToPush => {
    if (messageToPush) {
      return githubRequest(token, commentUrl, 'POST', { body: messageToPush });
    }

    return Promise.resolve();
  };

  const beforeTask = (taskName, { status }) => {
    if (!_.isEmpty(status)) {
      return setStatus(STATUSES.PENDING, status.targetUrl, status.context, 'Running');
    }

    return Promise.resolve();
  };

  const listComments = () => githubRequest(token, commentUrl, 'GET');

  const patchComment = (commentId, body = '') =>
    githubRequest(token, `${allCommentsUrl}/${commentId}`, 'PATCH', { body });

  const metaKey = 'pyg-bot-comment-flag-';

  const createOrUpdateComment = (message, key = 'default-key') => {
    if (!message) {
      return Promise.reject(new Error('Please provide a message to createOrUpdateComment method'));
    }

    return listComments().then(comments => {
      const matchingKey = metaKey + key;
      const finalMessage = `<!-- ${matchingKey} -->\n\n${message}`;
      const matchingComments = _.filter(comments, ({ body }) => body.match(new RegExp(matchingKey)));
      const commentId = _.get(matchingComments[0], 'id');

      if (commentId) {
        return patchComment(commentId, finalMessage);
      }

      return pushComment(finalMessage);
    });
  };

  const taskProcess = (taskName, { label, message, status }, successful) => {
    const promises = [];
    if (successful) {
      if (!_.isEmpty(label)) {
        promises.push(pushLabel(label.success));
      }

      if (!_.isEmpty(message)) {
        promises.push(pushComment(message.success));
      }

      if (!_.isEmpty(status)) {
        promises.push(setStatus(STATUSES.SUCCESS, status.targetUrl, status.context, 'Success!'));
      }
    } else {
      if (!_.isEmpty(label)) {
        promises.push(pushLabel(label.error));
      }

      if (!_.isEmpty(message)) {
        promises.push(pushComment(message.error));
      }

      if (!_.isEmpty(status)) {
        promises.push(setStatus(STATUSES.FAILURE, '', status.context, 'Failure!'));
      }
    }

    return Promise.all(promises);
  };

  return {
    getLabels,
    pushLabel,
    STATUSES,
    setStatus,
    createOrUpdateComment,
    pushComment,
    beforeTask,
    onTaskComplete: () => {},
    onBuildComplete: () => {},
    taskProcess,
  };
};
