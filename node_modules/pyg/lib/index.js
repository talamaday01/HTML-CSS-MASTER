#!/usr/bin/env node
'use strict';

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _colors = require('colors');

var _colors2 = _interopRequireDefault(_colors);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _appRootPath = require('app-root-path');

var _appRootPath2 = _interopRequireDefault(_appRootPath);

var _minimist = require('minimist');

var _minimist2 = _interopRequireDefault(_minimist);

require('pygin-github');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const _require = require(`${_appRootPath2.default}/.pygrc.js`),
      {
  tasks,
  sequence,
  ignore = {},
  onBuildComplete = () => {},
  onTaskComplete = () => {}
} = _require,
      pluginsUsed = _objectWithoutProperties(_require, ['tasks', 'sequence', 'ignore', 'onBuildComplete', 'onTaskComplete']);

const { github: { branch = '' } } = pluginsUsed;

const { log } = console;
const logTitle = text => log(`► ${_colors2.default.underline(text)}\n`);
const logGreen = text => log(`${_colors2.default.black.bgGreen(` ${text} `)}\n`);
const logGrey = text => log(`${_colors2.default.black.bgCyan(` ${text} `)}\n`);
const logRed = text => log(`${_colors2.default.black.bgRed(` ${text} `)}\n`);

const currentBranch = branch.replace('origin/', '');

const spawnTasks = [];
const processedTasks = [];

const onBuildCompleteSeries = [onBuildComplete];
const onTaskCompleteSeries = [onTaskComplete];

// Require pluginsUsed
const pluginsTab = _lodash2.default.reduce(pluginsUsed, (result, pluginConfig, pluginName) => {
  const pluginsTmp = result;
  const { triggerOnBuildComplete, triggerOnTaskComplete } = pluginConfig;

  // eslint-disable-next-line global-require
  const plugin = require(`pygin-${pluginName}`).default(pluginConfig);

  if (triggerOnBuildComplete) {
    onBuildCompleteSeries.unshift(plugin.onBuildComplete);
  }

  if (triggerOnTaskComplete) {
    onTaskCompleteSeries.unshift(plugin.onTaskComplete);
  }

  pluginsTmp[pluginName] = plugin;

  return pluginsTmp;
}, {});

/**
 * This handle the before task
 * @param  {String} taskName
 * @param  {Object} pluginsOfTask
 */
const beforeTaskHandler = (taskName, pluginsOfTask) => Promise.all(_lodash2.default.map(pluginsOfTask, (pluginConfig, pluginName) => pluginsTab[pluginName].beforeTask(taskName, pluginConfig)));

/**
 * This handler is run at the end of each task
 * @param  {String} taskName
 * @param  {Object} pluginsOfTask
 * @param  {Bool} failOnError
 * @param  {Bool} successful
 * @param  {String} message
 */
const buildTaskHandler = (taskName, pluginsOfTask, failOnError) => async (successful, message) => {
  // Process plugins
  await Promise.all(_lodash2.default.map(pluginsOfTask, (pluginConfig, pluginName) => pluginsTab[pluginName].taskProcess(taskName, pluginConfig, successful)));

  if (successful) {
    processedTasks.push({ taskName, successful: true });
    logGreen(message);
  } else {
    if (failOnError) {
      process.exitCode = 1;
    }

    processedTasks.push({ taskName, successful: false });
    logRed(message);
  }

  try {
    _lodash2.default.forEach(onTaskCompleteSeries, handler => handler(taskName, successful, pluginsTab));
  } catch (error) {
    log(error.stack);
  }

  return null;
};

/**
 * This handler is run at the end of the build
 * @param  {Number} startTime
 * @param  {Number} exitCode
 */
const exitHandler = (startTime, exitCode) => {
  const processDuration = process.hrtime(startTime);
  const durationInSeconds = processDuration[0];

  // eslint-disable-next-line no-underscore-dangle
  const takenTime = `${_lodash2.default.floor(durationInSeconds / 60)}min ${durationInSeconds % 60}`;

  log(`Build ${!exitCode ? 'successfully finished' : 'failed'} in ${takenTime}.`);

  if (processedTasks.length) {
    try {
      const promisesSeries = _lodash2.default.map(onBuildCompleteSeries, handler => handler(!exitCode, processedTasks, pluginsTab));

      return Promise.all(promisesSeries).then(() => process.exit(exitCode)).catch(() => process.exit(exitCode));
    } catch (error) {
      log(error.stack);
    }
  }

  return process.exit(exitCode);
};

// Run the build process
const startTime = process.hrtime();

pluginsTab.github.getLabels().then(pullRequestLabels => {
  // Check ignore labels
  const ignoreLabels = _lodash2.default.intersection(pullRequestLabels, ignore.labels);
  if (!_lodash2.default.isEmpty(ignore.labels) && !_lodash2.default.isEmpty(pullRequestLabels) && ignoreLabels.length) {
    log(`This build is ignored due to these labels: ${ignoreLabels.join(', ')}.`);

    return;
  }

  // Check ignore branches
  if (!_lodash2.default.isEmpty(ignore.branches) && ignore.branches.indexOf(currentBranch) !== -1) {
    log(`This build is ignored because the current branch is: ${currentBranch}.`);

    return;
  }

  // Run tasks sequentially
  const tasksArgument = (0, _minimist2.default)(process.argv.slice(2), { boolean: 'color' })._;
  let promiseChain = Promise.resolve();
  let tasksList = tasks;
  let tasksToRun = tasksArgument.length ? tasksArgument : sequence;

  if (typeof tasksToRun === 'function') {
    tasksToRun = tasksToRun(pullRequestLabels);
  }

  if (typeof tasks === 'function') {
    tasksList = tasks(pullRequestLabels);
  }

  _lodash2.default.forEach(tasksToRun, taskName => {
    let runTask;

    const _ref = tasksList[taskName] || {},
          {
      cmd,
      env,
      spawn,
      dependsOn = [],
      failOnError = true,
      filter = () => true,
      log: { standardFile, errorFile } = {}
    } = _ref,
          pluginsOfTask = _objectWithoutProperties(_ref, ['cmd', 'env', 'spawn', 'dependsOn', 'failOnError', 'filter', 'log']);

    const handler = buildTaskHandler(taskName, pluginsOfTask, failOnError);

    if (!tasksList[taskName]) {
      runTask = () => logTitle(`Task "${taskName}" is ignored because it is not defined.`);
    } else if (!filter(pullRequestLabels)) {
      // Custom filter
      const labels = !_lodash2.default.isEmpty(pullRequestLabels) ? `(PR labels are ${pullRequestLabels.join(', ')})` : '(PR has no label)';
      runTask = () => logTitle(`Task "${taskName}" is ignored because of custom filter ${labels}.`);
    } else {
      runTask = () => new Promise(async (resolve, reject) => {
        // Check task dependencies
        let parentTask;
        let parentTaskName;
        let mustBeSuccessful;
        const areDependenciesOK = dependsOn.every(task => {
          mustBeSuccessful = task.indexOf('!') !== 0;
          parentTaskName = mustBeSuccessful ? task : task.substr(1);
          parentTask = _lodash2.default.find(processedTasks, processedTask => processedTask.taskName === parentTaskName);

          if (!parentTask || parentTask.successful !== mustBeSuccessful) {
            return false;
          }

          return true;
        });

        if (!areDependenciesOK) {
          let message;
          if (parentTask) {
            message = `${parentTask.taskName} is${mustBeSuccessful ? ' not' : ''} successful`;
          } else {
            message = `${parentTaskName} have not been executed`;
          }

          logTitle(`Task "${taskName}" is ignored because ${message}.`);
          resolve();

          return;
        }

        logTitle(`Task "${taskName}" is running...`);

        await beforeTaskHandler(taskName, pluginsOfTask);

        // Run command
        if (cmd) {
          log(`${spawn ? 'Spawned' : 'Run'} command: ${cmd}\n`);

          let logFileDescriptor = 1;
          let errorFileDescriptor = 2;

          if (standardFile) {
            logFileDescriptor = _fs2.default.openSync(standardFile, 'w');
          } else if (spawn) {
            logFileDescriptor = 'ignore';
          }

          if (errorFile) {
            errorFileDescriptor = _fs2.default.openSync(errorFile, 'w');
          } else if (spawn) {
            errorFileDescriptor = 'ignore';
          }

          const stdio = [0, logFileDescriptor, errorFileDescriptor];
          const commandArguments = cmd.split(' ');
          const spawnedProcess = _child_process2.default.spawn(commandArguments[0], commandArguments.slice(1), {
            env,
            stdio,
            shell: true,
            detached: spawn
          });

          if (spawn) {
            const pidProcess = spawnedProcess.pid;

            spawnedProcess.on('exit', code => {
              if (!code) {
                handler(true, `✔ Spawned process "${taskName}" has run without any error`);
              } else {
                handler(false, `✘ Spawned process "${taskName}" exits with code ${code}`);
              }

              _lodash2.default.remove(spawnTasks, { pid: pidProcess });
            });
            spawnedProcess.on('error', error => {
              handler(false, `✘ Spawned process "${taskName}" is in error`);
              log(`${error.stack}\n`);
            });

            spawnTasks.push(spawnedProcess);

            logGrey(`❁ Process "${taskName}" is running in background`);
            resolve();
          } else {
            spawnedProcess.on('close', () => resolve(true));
            spawnedProcess.on('exit', exitCode => {
              if (!exitCode) {
                resolve(true);
              } else {
                reject();
              }
            });
            spawnedProcess.on('error', reject);
          }
        } else {
          resolve(true);
        }
      });
    }

    const finalPromise = () => Promise.resolve(runTask()).then(executeHandler => executeHandler ? handler(true, `✔ "${taskName}" is successful`) : null).catch(error => {
      if (error && error.stack) {
        log(error.stack);
      }

      handler(false, `✘ "${taskName}" have failed!`);
    });

    promiseChain = promiseChain.then(finalPromise);
  });

  promiseChain.then(() => _lodash2.default.forEach(spawnTasks, task => {
    // Kill all spawned process group
    process.kill(-task.pid, 'SIGKILL');
  }));
});

process.on('beforeExit', exitHandler.bind(null, startTime));