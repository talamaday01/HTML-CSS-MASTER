#!/usr/bin/env node
import _ from 'lodash';
import childProcess from 'child_process';
import colors from 'colors';
import fs from 'fs';
import appRoot from 'app-root-path';
import minimist from 'minimist';
import 'pygin-github';

const {
  tasks,
  sequence,
  ignore = {},
  onBuildComplete = () => {},
  onTaskComplete = () => {},
  ...pluginsUsed
} = require(`${appRoot}/.pygrc.js`);

const { github: { branch = '' } } = pluginsUsed;

const { log } = console;
const logTitle = text => log(`► ${colors.underline(text)}\n`);
const logGreen = text => log(`${colors.black.bgGreen(` ${text} `)}\n`);
const logGrey = text => log(`${colors.black.bgCyan(` ${text} `)}\n`);
const logRed = text => log(`${colors.black.bgRed(` ${text} `)}\n`);

const currentBranch = branch.replace('origin/', '');

const spawnTasks = [];
const processedTasks = [];

const onBuildCompleteSeries = [onBuildComplete];
const onTaskCompleteSeries = [onTaskComplete];

// Require pluginsUsed
const pluginsTab = _.reduce(
  pluginsUsed,
  (result, pluginConfig, pluginName) => {
    const pluginsTmp = result;
    const { triggerOnBuildComplete, triggerOnTaskComplete } = pluginConfig;

    // eslint-disable-next-line global-require
    const plugin = require(`pygin-${pluginName}`).default(pluginConfig);

    if (triggerOnBuildComplete) {
      onBuildCompleteSeries.unshift(plugin.onBuildComplete);
    }

    if (triggerOnTaskComplete) {
      onTaskCompleteSeries.unshift(plugin.onTaskComplete);
    }

    pluginsTmp[pluginName] = plugin;

    return pluginsTmp;
  },
  {},
);

/**
 * This handle the before task
 * @param  {String} taskName
 * @param  {Object} pluginsOfTask
 */
const beforeTaskHandler = (taskName, pluginsOfTask) =>
  Promise.all(
    _.map(pluginsOfTask, (pluginConfig, pluginName) => pluginsTab[pluginName].beforeTask(taskName, pluginConfig)),
  );

/**
 * This handler is run at the end of each task
 * @param  {String} taskName
 * @param  {Object} pluginsOfTask
 * @param  {Bool} failOnError
 * @param  {Bool} successful
 * @param  {String} message
 */
const buildTaskHandler = (taskName, pluginsOfTask, failOnError) => async (successful, message) => {
  // Process plugins
  await Promise.all(
    _.map(pluginsOfTask, (pluginConfig, pluginName) =>
      pluginsTab[pluginName].taskProcess(taskName, pluginConfig, successful),
    ),
  );

  if (successful) {
    processedTasks.push({ taskName, successful: true });
    logGreen(message);
  } else {
    if (failOnError) {
      process.exitCode = 1;
    }

    processedTasks.push({ taskName, successful: false });
    logRed(message);
  }

  try {
    _.forEach(onTaskCompleteSeries, handler => handler(taskName, successful, pluginsTab));
  } catch (error) {
    log(error.stack);
  }

  return null;
};

/**
 * This handler is run at the end of the build
 * @param  {Number} startTime
 * @param  {Number} exitCode
 */
const exitHandler = (startTime, exitCode) => {
  const processDuration = process.hrtime(startTime);
  const durationInSeconds = processDuration[0];

  // eslint-disable-next-line no-underscore-dangle
  const takenTime = `${_.floor(durationInSeconds / 60)}min ${durationInSeconds % 60}`;

  log(`Build ${!exitCode ? 'successfully finished' : 'failed'} in ${takenTime}.`);

  if (processedTasks.length) {
    try {
      const promisesSeries = _.map(onBuildCompleteSeries, handler => handler(!exitCode, processedTasks, pluginsTab));

      return Promise.all(promisesSeries)
        .then(() => process.exit(exitCode))
        .catch(() => process.exit(exitCode));
    } catch (error) {
      log(error.stack);
    }
  }

  return process.exit(exitCode);
};

// Run the build process
const startTime = process.hrtime();

pluginsTab.github.getLabels().then(pullRequestLabels => {
  // Check ignore labels
  const ignoreLabels = _.intersection(pullRequestLabels, ignore.labels);
  if (!_.isEmpty(ignore.labels) && !_.isEmpty(pullRequestLabels) && ignoreLabels.length) {
    log(`This build is ignored due to these labels: ${ignoreLabels.join(', ')}.`);

    return;
  }

  // Check ignore branches
  if (!_.isEmpty(ignore.branches) && ignore.branches.indexOf(currentBranch) !== -1) {
    log(`This build is ignored because the current branch is: ${currentBranch}.`);

    return;
  }

  // Run tasks sequentially
  const tasksArgument = minimist(process.argv.slice(2), { boolean: 'color' })._;
  let promiseChain = Promise.resolve();
  let tasksList = tasks;
  let tasksToRun = tasksArgument.length ? tasksArgument : sequence;

  if (typeof tasksToRun === 'function') {
    tasksToRun = tasksToRun(pullRequestLabels);
  }

  if (typeof tasks === 'function') {
    tasksList = tasks(pullRequestLabels);
  }

  _.forEach(tasksToRun, taskName => {
    let runTask;

    const {
      cmd,
      env,
      spawn,
      dependsOn = [],
      failOnError = true,
      filter = () => true,
      log: { standardFile, errorFile } = {},
      ...pluginsOfTask
    } =
      tasksList[taskName] || {};

    const handler = buildTaskHandler(taskName, pluginsOfTask, failOnError);

    if (!tasksList[taskName]) {
      runTask = () => logTitle(`Task "${taskName}" is ignored because it is not defined.`);
    } else if (!filter(pullRequestLabels)) {
      // Custom filter
      const labels = !_.isEmpty(pullRequestLabels)
        ? `(PR labels are ${pullRequestLabels.join(', ')})`
        : '(PR has no label)';
      runTask = () => logTitle(`Task "${taskName}" is ignored because of custom filter ${labels}.`);
    } else {
      runTask = () =>
        new Promise(async (resolve, reject) => {
          // Check task dependencies
          let parentTask;
          let parentTaskName;
          let mustBeSuccessful;
          const areDependenciesOK = dependsOn.every(task => {
            mustBeSuccessful = task.indexOf('!') !== 0;
            parentTaskName = mustBeSuccessful ? task : task.substr(1);
            parentTask = _.find(processedTasks, processedTask => processedTask.taskName === parentTaskName);

            if (!parentTask || parentTask.successful !== mustBeSuccessful) {
              return false;
            }

            return true;
          });

          if (!areDependenciesOK) {
            let message;
            if (parentTask) {
              message = `${parentTask.taskName} is${mustBeSuccessful ? ' not' : ''} successful`;
            } else {
              message = `${parentTaskName} have not been executed`;
            }

            logTitle(`Task "${taskName}" is ignored because ${message}.`);
            resolve();

            return;
          }

          logTitle(`Task "${taskName}" is running...`);

          await beforeTaskHandler(taskName, pluginsOfTask);

          // Run command
          if (cmd) {
            log(`${spawn ? 'Spawned' : 'Run'} command: ${cmd}\n`);

            let logFileDescriptor = 1;
            let errorFileDescriptor = 2;

            if (standardFile) {
              logFileDescriptor = fs.openSync(standardFile, 'w');
            } else if (spawn) {
              logFileDescriptor = 'ignore';
            }

            if (errorFile) {
              errorFileDescriptor = fs.openSync(errorFile, 'w');
            } else if (spawn) {
              errorFileDescriptor = 'ignore';
            }

            const stdio = [0, logFileDescriptor, errorFileDescriptor];
            const commandArguments = cmd.split(' ');
            const spawnedProcess = childProcess.spawn(commandArguments[0], commandArguments.slice(1), {
              env,
              stdio,
              shell: true,
              detached: spawn,
            });

            if (spawn) {
              const pidProcess = spawnedProcess.pid;

              spawnedProcess.on('exit', code => {
                if (!code) {
                  handler(true, `✔ Spawned process "${taskName}" has run without any error`);
                } else {
                  handler(false, `✘ Spawned process "${taskName}" exits with code ${code}`);
                }

                _.remove(spawnTasks, { pid: pidProcess });
              });
              spawnedProcess.on('error', error => {
                handler(false, `✘ Spawned process "${taskName}" is in error`);
                log(`${error.stack}\n`);
              });

              spawnTasks.push(spawnedProcess);

              logGrey(`❁ Process "${taskName}" is running in background`);
              resolve();
            } else {
              spawnedProcess.on('close', () => resolve(true));
              spawnedProcess.on('exit', exitCode => {
                if (!exitCode) {
                  resolve(true);
                } else {
                  reject();
                }
              });
              spawnedProcess.on('error', reject);
            }
          } else {
            resolve(true);
          }
        });
    }

    const finalPromise = () =>
      Promise.resolve(runTask())
        .then(executeHandler => (executeHandler ? handler(true, `✔ "${taskName}" is successful`) : null))
        .catch(error => {
          if (error && error.stack) {
            log(error.stack);
          }

          handler(false, `✘ "${taskName}" have failed!`);
        });

    promiseChain = promiseChain.then(finalPromise);
  });

  promiseChain.then(() =>
    _.forEach(spawnTasks, task => {
      // Kill all spawned process group
      process.kill(-task.pid, 'SIGKILL');
    }),
  );
});

process.on('beforeExit', exitHandler.bind(null, startTime));
